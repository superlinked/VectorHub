# Multi-attribute search with vector embeddings

## Motivation

Vector search has revolutionized data retrieval by leveraging semantic meaning. However, real-world scenarios often require searching across multiple attributes simultaneously, with varying degrees of importance for each. Two main approaches exist for multi-attribute vector search:

1. Search attributes separately, then combine weighted results.
2. Combine weighted attribute vectors, then perform a single search.

This article demonstrates why the first approach, despite its intuitive appeal, falls short even in simple cases. We'll explore why the second approach is superior and how to implement it efficiently using the Superlinked framework.

By understanding these methods, you'll gain insights into creating more powerful and flexible search systems that can handle complex, multi-faceted queries with ease.

## Setting

Let's bring our example to life with an exciting scenario!

Imagine it's game night, and you're the Dungeon Master for an epic Dungeons & Dragons adventure. For those unfamiliar, Dungeons & Dragons (D&D) is a popular tabletop role-playing game where players create characters and embark on imaginary quests guided by a storyteller, known as the Dungeon Master. Your friends are gathered around, eager to start a new quest. As the Dungeon Master, you're responsible for crafting thrilling encounters that challenge and excite your players.

Your trusty Monster Manual contains thousands of creatures, but finding the perfect monster for each situation can be overwhelming. The ideal foe needs to match the setting, difficulty, and narrative of the moment â€“ all while surprising and delighting your players.

What if we could create a tool that instantly finds the most suitable monsters for any scenario? A tool that considers multiple factors simultaneously, ensuring each encounter is as immersive and exciting as possible?

Let's embark on our own quest to build this ultimate monster-finding system, using the power of multi-attribute vector search!

## Dataset

To demonstrate our search techniques, we'll use a small synthetic dataset generated by a Large Language Model (LLM). Here's the prompt used to create our monster database:

```
Generate two JSON lists: 'monsters' and 'queries'.

1. 'monsters' list: Create 20 unique monsters with the following properties:
   - name: A distinctive name
   - look: Brief description of appearance (2-3 sentences)
   - habitat: Where the monster lives (2-3 sentences)
   - behavior: How the monster acts (2-3 sentences)

   Ensure some monsters share similar features while remaining distinct.

2. 'queries' list: Create 5 queries to search for monsters:
   - Each query should be in the format: {look: "...", habitat: "...", behavior: "..."}
   - Use simple, brief descriptions (1-3 words per field)
   - Make queries somewhat general to match multiple monsters

Output format:
{
  "monsters": [
    {"name": "...", "look": "...", "habitat": "...", "behavior": "..."},
    ...
  ],
  "queries": [
    {"look": "...", "habitat": "...", "behavior": "..."},
    ...
  ]
}
```

Let's examine a sample of our generated dataset. Note that your results may differ due to the non-deterministic nature of LLM generation.

First five monsters:


|    | name             | look                                                      | habitat                                             | behavior                                                      |
|---:|:-----------------|:----------------------------------------------------------|:----------------------------------------------------|:--------------------------------------------------------------|
|  0 | Luminoth         | Moth-like creature with glowing wings and antenna         | Dense forests and jungles with bioluminescent flora | Emits soothing light patterns to communicate and attract prey |
|  1 | Aqua Wraith      | Translucent humanoid figure made of flowing water         | Rivers, lakes, and coastal areas                    | Shapeshifts to blend with water bodies and controls currents  |
|  2 | Stoneheart Golem | Massive humanoid composed of interlocking rock formations | Rocky mountains and ancient ruins                   | Hibernates for centuries, awakens to protect its territory    |
|  3 | Whispering Shade | Shadowy, amorphous being with glowing eyes                | Dark forests and abandoned buildings                | Feeds on fear and whispers unsettling truths                  |
|  4 | Zephyr Dancer    | Graceful avian creature with iridescent feathers          | High mountain peaks and wind-swept plains           | Creates mesmerizing aerial displays to attract mates          |

And here are the queries:

|    | look          | habitat              | behavior              |
|---:|:--------------|:---------------------|:----------------------|
|  0 | glowing       | dark places          | light manipulation    |
|  1 | elemental     | extreme environments | environmental control |
|  2 | shapeshifting | varied landscapes    | illusion creation     |
|  3 | crystalline   | mineral-rich areas   | energy absorption     |
|  4 | ethereal      | atmospheric          | mind influence        |

Original dataset and query examples are available [here](https://github.com/superlinked/article-multi-attribute-search).

## Retrieval

Let's set up common parameters for both approaches we'll explore: the naive method and the Superlinked method.

We'll use the `sentence-transformers/all-mpnet-base-v2` model from the Sentence Transformers library to generate our vector embeddings. To keep our results short, we'll limit the output to the top 3 matches.

```python
LIMIT = 3
MODEL_NAME = "sentence-transformers/all-mpnet-base-v2"
```

For the complete code, including necessary imports and helper functions, please refer to the [accompanying notebook](https://github.com/superlinked/article-multi-attribute-search).

If you're new to vector similarity search, don't worry! You can find definitions for key terms in the "Glossary" section at the end of this article.

Now, let's dive into our two approaches for multi-attribute monster search.

### Naive approach

```python
class NaiveRetriever:
    def __init__(self, data: pd.DataFrame):
        self.model = SentenceTransformer(MODEL_NAME)
        self.data = data.copy()
        self.ids = self.data.index.to_list()
        self.knns = {}
        for key in self.data:
            embeddings = self.model.encode(self.data[key].values)
            knn = NearestNeighbors(metric="cosine").fit(embeddings)
            self.knns[key] = knn

    def search_key(self, key: str, value: str, limit: int = LIMIT) -> pd.DataFrame:
        embedding = self.model.encode(value)
        knn = self.knns[key]
        distances, indices = knn.kneighbors(
            [embedding], n_neighbors=limit, return_distance=True
        )
        ids = [self.ids[i] for i in indices[0]]

        similarities = (1 - distances).flatten()
        # by definition:
        # cosine distance = 1 - cosine similarity

        result = pd.DataFrame(
            {"id": ids, f"score_{key}": similarities, key: self.data[key][ids]}
        )
        result.set_index("id", inplace=True)

        return result

    def search(self, query: dict, limit: int = LIMIT) -> pd.DataFrame:
        results = []
        for key, value in query.items():
            if key not in self.knns:
                continue
            result_key = self.search_key(key, value, limit=limit)
            result_key.drop(columns=[key], inplace=True)
            results.append(result_key)

        merged_results = pd.concat(results, axis=1)
        merged_results["score"] = merged_results.mean(axis=1, skipna=False)
        merged_results.sort_values("score", ascending=False, inplace=True)
        return merged_results
```

Let's take the first query from our list and search for monsters using the naive approach:

```python
query = {
    'look': 'glowing',
    'habitat': 'dark places',
    'behavior': 'light manipulation'
}
```

Here are search results for each attribute:

**Look: glowing**
| id               |   score_look | look                                              |
|:-----------------|-------------:|:--------------------------------------------------|
| Whispering Shade |     0.503578 | Shadowy, amorphous being with glowing eyes        |
| Sandstorm Djinn  |     0.407344 | Swirling vortex of sand with glowing symbols      |
| Luminoth         |     0.378619 | Moth-like creature with glowing wings and antenna |

Awesome, these are relevant creatures, all have something "glowing" in them as we asked for!
Let's see what we can find for other two attributes.

**Habitat: dark places**
| id                  |   score_habitat | habitat                              |
|:--------------------|----------------:|:-------------------------------------|
| Whispering Shade    |        0.609567 | Dark forests and abandoned buildings |
| Fungal Network      |        0.438856 | Underground caverns and damp forests |
| Thornvine Elemental |        0.423421 | Overgrown ruins and dense jungles    |

**Behavior: light manipulation**
| id                |   score_behavior | behavior                                                       |
|:------------------|-----------------:|:---------------------------------------------------------------|
| Living Graffiti   |         0.385741 | Shapeshifts to blend with surroundings and absorbs pigments    |
| Crystalwing Drake |         0.385211 | Hoards precious gems and can refract light into powerful beams |
| Luminoth          |         0.345566 | Emits soothing light patterns to communicate and attract prey  |

These results look promising at first glance, but we must remember our original goal: finding monsters that are relevant across all attributes simultaneously. This is where the limitations of our naive approach become apparent. Let's merge the results to see the full picture:

| id                  |   score_look |   score_habitat |   score_behavior |
|:--------------------|-------------:|----------------:|-----------------:|
| Whispering Shade    |     0.503578 |        0.609567 |                  |
| Sandstorm Djinn     |     0.407344 |                 |                  |
| Luminoth            |     0.378619 |                 |         0.345566 |
| Fungal Network      |              |        0.438856 |                  |
| Thornvine Elemental |              |        0.423421 |                  |
| Living Graffiti     |              |                 |         0.385741 |
| Crystalwing Drake   |              |                 |         0.385211 |

What we have here:

1. Relevance by attribute:
   - "Look": Three monsters were retrieved (Whispering Shade, Sandstorm Djinn, and Luminoth).
   - "Habitat": Only one monster from the "Look" results was relevant (Whispering Shade).
   - "Behavior": Only one monster from the "Look" results was relevant (Luminoth), but it's different from the one relevant for "Habitat".

2. Overall relevance:
   - No single monster was retrieved for all three attributes simultaneously.
   - The results are fragmented, with different monsters being relevant for different attributes.

This fragmentation in the results highlights a potential issue with our current search approach, as it fails to find monsters that satisfy all criteria at once.

Maybe we can fix this issue by proactively retrieving more monsters for each attribute?
Let's try it with 6 monsters for each attribute instead of 3.

| id                  |   score_look |   score_habitat |   score_behavior |
|:--------------------|-------------:|----------------:|-----------------:|
| Whispering Shade    |     0.503578 |        0.609567 |                  |
| Sandstorm Djinn     |     0.407344 |        0.365061 |                  |
| Luminoth            |     0.378619 |                 |         0.345566 |
| Nebula Jellyfish    |     0.36627  |                 |         0.259969 |
| Dreamweaver Octopus |     0.315679 |                 |                  |
| Quantum Firefly     |     0.288578 |                 |                  |
| Fungal Network      |              |        0.438856 |                  |
| Thornvine Elemental |              |        0.423421 |                  |
| Mist Phantom        |              |        0.366816 |         0.236649 |
| Stoneheart Golem    |              |        0.342287 |                  |
| Living Graffiti     |              |                 |         0.385741 |
| Crystalwing Drake   |              |                 |         0.385211 |
| Aqua Wraith         |              |                 |         0.283581 |

In total, we retrieved 13 monsters (that is more than half of our tiny dataset!) and still have the same issue: no monster was retrieved for all three attributes simultaneously.
We could try to increase the number of monsters further, but it would result in the following shortcomings:
1. While not a problem for our toy task, in production it will result in noticeably longer search time. And generally, multiple KNN searches take more time than a single one with concatenated vectors ([redis benchmark](https://redis.io/blog/benchmarking-results-for-vector-databases/)).
2. With more attributes, the number of monsters to retrieve for every attribute will grow exponentially.
3. And there is still no guarantee that this will result in retrieval of monsters that satisfy all criteria at once.
4. Even if we somehow manage to retrieve monsters that satisfy all criteria at once, we would still need to perform reconciliation of results that would result in additional overhead in a production system.

This example is enough to show that the naive approach is not suitable for our task. 

### Superlinked approach

Let's implement the second approach using Superlinked framework.

First, let's define the schema, spaces, index and query:

```python
@schema
class Monster:
    id: IdField
    look: String
    habitat: String
    behavior: String


monster = Monster()

look_space = TextSimilaritySpace(text=monster.look, model=MODEL_NAME)
habitat_space = TextSimilaritySpace(text=monster.habitat, model=MODEL_NAME)
behavior_space = TextSimilaritySpace(text=monster.behavior, model=MODEL_NAME)

monster_index = Index([look_space, habitat_space, behavior_space])

monster_query = (
    Query(monster_index)
    .find(monster)
    .similar(look_space.text, Param("look"))
    .similar(habitat_space.text, Param("habitat"))
    .similar(behavior_space.text, Param("behavior"))
    .limit(LIMIT)
)
```

Finally, start executor and upload the data:

```python
monster_parser = DataFrameParser(monster, mapping={monster.id: "name"})

source: InMemorySource = InMemorySource(monster, parser=monster_parser)
executor = InMemoryExecutor(sources=[source], indices=[monster_index])
app = executor.run()

source.put([df])
```

Let's run the same query as before:

```python
query = {
    'look': 'glowing',
    'habitat': 'dark places',
    'behavior': 'light manipulation'
}
```

| id               |    score | look                                                           | habitat                                             | behavior                                                      |
|:-----------------|---------:|:---------------------------------------------------------------|:----------------------------------------------------|:--------------------------------------------------------------|
| Whispering Shade | 0.376738 | Shadowy, amorphous being with glowing eyes                     | Dark forests and abandoned buildings                | Feeds on fear and whispers unsettling truths                  |
| Luminoth         | 0.340084 | Moth-like creature with glowing wings and antenna              | Dense forests and jungles with bioluminescent flora | Emits soothing light patterns to communicate and attract prey |
| Living Graffiti  | 0.330587 | Two-dimensional, colorful creature that inhabits flat surfaces | Urban areas, particularly walls and billboards      | Shapeshifts to blend with surroundings and absorbs pigments   |

As you can see, the results contain monsters that satisfy all criteria at once.

Let's try another query.

```python
query = {
    'look': 'shapeshifting',
    'habitat': 'varied landscapes',
    'behavior': 'illusion creation'
}
```

| id               |    score | look                                               | habitat                                   | behavior                                             |
|:-----------------|---------:|:---------------------------------------------------|:------------------------------------------|:-----------------------------------------------------|
| Mist Phantom     | 0.489574 | Ethereal, fog-like humanoid with shifting features | Swamps, moors, and foggy coastlines       | Lures travelers astray with illusions and whispers   |
| Zephyr Dancer    | 0.342075 | Graceful avian creature with iridescent feathers   | High mountain peaks and wind-swept plains | Creates mesmerizing aerial displays to attract mates |
| Whispering Shade | 0.337434 | Shadowy, amorphous being with glowing eyes         | Dark forests and abandoned buildings      | Feeds on fear and whispers unsettling truths         |

Great!
Maybe we would like to find monsters from the dataset similar to the existing one?
Let's try it with the "Harmonic Coral" (very last row in our dataset).
We could extract attributes for this monsters and create query parameters manually, but Superlinked provides better way to query records similar to already stored ones.
We can do it with `with_vector` method of the query object. Since moster's id is its name, we can express our request as simple as this:

```python
app.query(
    monster_query.with_vector(
        monster,
        "Harmonic Coral"
    ),
    limit=LIMIT
)
```

| id                  |    score | look                                                                 | habitat                                  | behavior                                                       |
|:--------------------|---------:|:---------------------------------------------------------------------|:-----------------------------------------|:---------------------------------------------------------------|
| Harmonic Coral      | 1        | Branching, musical instrument-like structure with vibrating tendrils | Shallow seas and tidal pools             | Creates complex melodies to communicate and influence emotions |
| Dreamweaver Octopus | 0.402288 | Cephalopod with tentacles that shimmer like auroras                  | Deep ocean trenches and underwater caves | Influences the dreams of nearby creatures                      |
| Aqua Wraith         | 0.330869 | Translucent humanoid figure made of flowing water                    | Rivers, lakes, and coastal areas         | Shapeshifts to blend with water bodies and controls currents   |

The top result is the most relevant one, the "Harmonic Coral" itself which is pretty much expected.
Let's see who are the other two monsters: "Dreamweaver Octopus" and "Aqua Wraith".

Both share important thematic elements with the Harmonic Coral:
1. Aquatic habitats
2. Ability to influence or manipulate their environment
3. Dynamic or fluid visual characteristics
These common themes in habitat, behavior, and appearance explain why these monsters were identified as most similar to the Harmonic Coral.

### Attribute weighing

Let's suppose that we want to give more importance to the "look" attribute.
It's easy to do with Superlinked.
All we need to do is to add weights to the query.

```python
monster_query_with_weights = (
    Query(monster_index, weights={
        look_space: Param("look_weight"),
        habitat_space: Param("habitat_weight"),
        behavior_space: Param("behavior_weight")
    })
    .find(monster)
    .similar(look_space.text, Param("look"))
    .similar(habitat_space.text, Param("habitat"))
    .similar(behavior_space.text, Param("behavior"))
    .limit(LIMIT)
)
```

Let's again search for similar monsters to the "Harmonic Coral", but this time use weights for the attributes.
First of all, let's find monsters with the most close appearance:

```python
weights = {
    "look_weight": 1.0,
    "habitat_weight": 0,
    "behavior_weight": 0
}
```

| id                  |    score | look                                                                 | habitat                            | behavior                                                       |
|:--------------------|---------:|:---------------------------------------------------------------------|:-----------------------------------|:---------------------------------------------------------------|
| Harmonic Coral      | 0.57735  | Branching, musical instrument-like structure with vibrating tendrils | Shallow seas and tidal pools       | Creates complex melodies to communicate and influence emotions |
| Thornvine Elemental | 0.252593 | Plant-like creature with a body of twisted vines and thorns          | Overgrown ruins and dense jungles  | Rapidly grows and controls surrounding plant life              |
| Plasma Serpent      | 0.243241 | Snake-like creature made of crackling energy                         | Electrical storms and power plants | Feeds on electrical currents and can short-circuit technology  |

"Branching with vibrating tendrils", "Plant-like creature with a body of twisted vines and thorns", "Snake-like" -- for sure these descriptions share some common theme.

Let's search by "habitat" and "behaviour" simultaneously:

```python
weights = {
    "look_weight": 0,
    "habitat_weight": 1.0,
    "behavior_weight": 1.0
}
```

| id                  |    score | look                                                                 | habitat                                  | behavior                                                       |
|:--------------------|---------:|:---------------------------------------------------------------------|:-----------------------------------------|:---------------------------------------------------------------|
| Harmonic Coral      | 0.816497 | Branching, musical instrument-like structure with vibrating tendrils | Shallow seas and tidal pools             | Creates complex melodies to communicate and influence emotions |
| Dreamweaver Octopus | 0.357656 | Cephalopod with tentacles that shimmer like auroras                  | Deep ocean trenches and underwater caves | Influences the dreams of nearby creatures                      |
| Mist Phantom        | 0.288106 | Ethereal, fog-like humanoid with shifting features                   | Swamps, moors, and foggy coastlines      | Lures travelers astray with illusions and whispers             |

All three monsters live in some watery habitats and have mind-controlling abilities.

Lastly, let's try to use all attributes with different weights:

```python
weights = {
    "look_weight": 0.5,
    "habitat_weight": -1.0,
    "behavior_weight": 1.0
}
```

Such set of weights means that we want to find monsters that have similar behaviour, somewhat similar look, but live in different habitats for the one Harmonic Coral prefers.

| id             |    score | look                                                                 | habitat                                             | behavior                                                       |
|:---------------|---------:|:---------------------------------------------------------------------|:----------------------------------------------------|:---------------------------------------------------------------|
| Harmonic Coral | 0.19245  | Branching, musical instrument-like structure with vibrating tendrils | Shallow seas and tidal pools                        | Creates complex melodies to communicate and influence emotions |
| Luminoth       | 0.149196 | Moth-like creature with glowing wings and antenna                    | Dense forests and jungles with bioluminescent flora | Emits soothing light patterns to communicate and attract prey  |
| Zephyr Dancer  | 0.136456 | Graceful avian creature with iridescent feathers                     | High mountain peaks and wind-swept plains           | Creates mesmerizing aerial displays to attract mates           |

Two retrievel monsters (Luminoth and Zephyr Dancer) are indeed similar to the Harmonic Coral in terms of behaviour, but live in different habitats.
In terms of look, there is little similarity between Harmonic Coral and Luminoth since antenna could look like tendrils, but it's not the same for sure.
Anyway, this attribute was half-important for us, so we can compensate here.

## Conclusion

Multi-attribute vector search represents a significant advancement in information retrieval, offering a more nuanced and effective approach compared to traditional search methods.
As demonstrated through our D&D monster example, this technique excels at finding relevant results when multiple criteria are involved.

Key takeaways:
1. Vector embeddings capture semantic meaning, allowing for more intelligent searches.
2. The Superlinked framework provides an efficient way to implement multi-attribute vector search.
3. Attribute weighting adds flexibility, allowing users to prioritize certain criteria over others.

As data continues to grow in complexity and volume, multi-attribute vector search will play an increasingly crucial role in various applications, from e-commerce to content recommendation systems.
By understanding and implementing these techniques, developers and data scientists can create more powerful, intuitive, and user-friendly search experiences.

Whether you're battling monsters in a fantasy realm or tackling real-world data challenges, multi-attribute vector search offers a powerful tool for finding the perfect match in a sea of possibilities.

## Glossary

- **Vector Embedding**: A numerical representation of data (like text or images) in a high-dimensional space, capturing semantic meaning.

- **Cosine Similarity**: A measure of similarity between two vectors, often used in vector search to determine how closely related two items are.

- **Multi-attribute Search**: A search method that considers multiple characteristics or properties of items simultaneously.

- **Semantic Meaning**: The underlying concept or idea represented by data, rather than just its literal interpretation.

- **Nearest Neighbors**: In vector search, the items that are most similar or closest to a given query in the vector space.

- **Large Language Model (LLM)**: An AI model trained on vast amounts of text data, capable of generating human-like text and performing various language tasks.

- **Sentence Transformer**: A type of model that converts sentences or short texts into vector embeddings.

- **Index**: In the context of vector search, a data structure that organizes vector embeddings for efficient retrieval.

- **Query**: A request for information from a search system, often represented as a vector in vector search.

- **Attribute Weighting**: Assigning different levels of importance to various attributes in a multi-attribute search.